package vulnerability

import (
	"fmt"

	"github.com/NucleoFusion/cruise/internal/colors"
	"github.com/NucleoFusion/cruise/internal/config"
	"github.com/NucleoFusion/cruise/internal/docker"
	"github.com/NucleoFusion/cruise/internal/messages"
	"github.com/NucleoFusion/cruise/internal/styles"
	"github.com/NucleoFusion/cruise/internal/utils"
	"github.com/charmbracelet/bubbles/textinput"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type VulnerabilityList struct {
	Width         int
	Height        int
	Items         []docker.Vulnerability
	SelectedIndex int
	Focused       bool
	Ti            textinput.Model
	Vp            viewport.Model
	IsScanning    bool
}

func NewVulnerabilityList(w int, h int) *VulnerabilityList {
	ti := textinput.New()
	ti.Width = w - 7
	ti.Prompt = " Image: "
	ti.Placeholder = "Enter image name to scan..."

	ti.PromptStyle = lipgloss.NewStyle().Foreground(colors.Load().FocusedBorder)
	ti.PlaceholderStyle = lipgloss.NewStyle().Foreground(colors.Load().PlaceholderText)
	ti.TextStyle = styles.TextStyle()

	vp := viewport.New(w, h-6) // Border and Headers

	return &VulnerabilityList{
		Width:         w,
		Height:        h,
		Ti:            ti,
		SelectedIndex: 0,
		Vp:            vp,
	}
}

func (s *VulnerabilityList) Init() tea.Cmd {
	return nil
}

func (s *VulnerabilityList) Update(msg tea.Msg) (*VulnerabilityList, tea.Cmd) {
	switch msg := msg.(type) {
	case messages.ScanResponse:
		s.IsScanning = false
		if msg.Err != nil {
			return s, utils.ReturnError("Vulnerability Page", "Error While Scanning", msg.Err)
		}
		arr, err := Convert(msg.Arr)
		if err != nil {
			return s, utils.ReturnError("Vulnerability Page", "Error While Parsing", err)
		}

		s.Items = arr
		return s, nil
	case tea.KeyMsg:
		if s.Ti.Focused() {
			if msg.String() == config.Cfg.Keybinds.Global.UnfocusSearch {
				s.Ti.Blur()
				return s, nil
			}
			var cmd tea.Cmd
			s.Ti, cmd = s.Ti.Update(msg)
			s.UpdateList()
			return s, cmd
		}
		switch msg.String() {
		case config.Cfg.Keybinds.Global.FocusSearch:
			s.Ti.Focus()
			return s, nil
		case config.Cfg.Keybinds.Global.ListDown:
			if len(s.Items)-1 > s.SelectedIndex {
				s.SelectedIndex += 1
			}
			if s.SelectedIndex > s.Vp.Height+s.Vp.YOffset-1 {
				s.Vp.YOffset += 1
			}
			return s, nil
		case config.Cfg.Keybinds.Global.ListUp:
			if s.SelectedIndex > 0 {
				s.SelectedIndex -= 1
			}
			if s.SelectedIndex < s.Vp.YOffset {
				s.Vp.YOffset -= 1
			}
			return s, nil
		case "enter":
			if !s.Ti.Focused() {
				return s, nil
			}
			s.IsScanning = true
			return s, func() tea.Msg {
				return messages.StartScanMsg{Img: s.Ti.Value()}
			}
		}
	}

	var cmd tea.Cmd
	s.Ti, cmd = s.Ti.Update(msg)
	return s, cmd
}

func (s *VulnerabilityList) View() string {
	if len(s.Items) == 0 {
		s.Vp.SetContent("Run the Scanner to get Output")
	}

	style := styles.PageStyle()
	if !s.Focused {
		style = style.BorderForeground(colors.Load().UnfocusedBorder)
	}

	if s.IsScanning {
		return lipgloss.JoinVertical(lipgloss.Center,
			style.Render(s.Ti.View()),
			style.Padding(1).Render(lipgloss.Place(s.Width, s.Height-3, lipgloss.Center, lipgloss.Center, "Scanning...")))
	}

	s.UpdateList()

	return lipgloss.JoinVertical(lipgloss.Center,
		style.Render(s.Ti.View()),
		style.Padding(1).Render(lipgloss.JoinVertical(lipgloss.Center, lipgloss.NewStyle().Bold(true).Render(docker.VulnHeaders(s.Vp.Width-2))+"\n\n", s.Vp.View())))
}

func (s *VulnerabilityList) UpdateList() {
	text := ""
	for k, v := range s.Items {
		line := v.Format(s.Vp.Width - 2)

		if k == s.SelectedIndex {
			line = lipgloss.NewStyle().Background(colors.Load().MenuSelectedBg).Foreground(colors.Load().MenuSelectedText).Render(line)
		} else {
			line = styles.TextStyle().Render(line)
		}

		text += line + "\n"
	}

	s.Vp.SetContent(text)
}

func Convert(in []any) ([]docker.Vulnerability, error) {
	out := make([]docker.Vulnerability, len(in))
	for i, v := range in {
		mt, ok := v.(docker.Vulnerability)
		if !ok {
			return nil, fmt.Errorf("element %d is not MyType", i)
		}
		out[i] = mt
	}
	return out, nil
}
